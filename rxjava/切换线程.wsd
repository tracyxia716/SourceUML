@startuml 切换线程
actor user

user->Schedulers : io()
Schedulers->RxJavaPlugins : onIoScheduler(Scheduler)
RxJavaPlugins->RxJavaPlugins :apply(Function<T,R>,T)
RxJavaPlugins-->user : 返回Scheduler对象

user->Observable : subscribeOn(Scheduler)
create ObservableSubscribeOn
Observable -> ObservableSubscribeOn: new
Observable->RxJavaPlugins : onAssembly(Observable)
note right : 实际传递的是ObservableSubscribeOn对象
RxJavaPlugins-->user : 返回Observable


user->Schedulers : newThread
Schedulers->RxJavaPlugins : onNewThreadScheduler(Scheduler)
RxJavaPlugins->RxJavaPlugins : apply(Function<T,R>,T)
RxJavaPlugins-->user : 返回Scheduler对象



user->Observable : observeOn(Scheduler)
Observable->Observable : observeOn(Scheduler,boolean,int)
note right : 这里第二参数传递的false，第三个参数传递的是Flowable.bufferSize()
create ObservableObserveOn
Observable->ObservableObserveOn : 创建OservableObser
Oservable->RxJavaPlugins : onAssembly(Observable)
RxJavaPlugins-->user : 返回ObservableSubscribeOn对象


user->Observable : subscribe
Observable ->  RxJavaPlugins : onSubscribe(Observable,Observer)
Observable -> ObservableObserveOn : subscribeActual
ObservableObserveOn -> Scheduler : createWorker()
create NewThreadWorker
NewThreadScheduler -> NewThreadWorker : new
NewThreadScheduler --> ObservableObserveOn : 返回NewThreadWorker

create ObserveOnObserver
ObservableObserveOn -> ObserveOnObserver : new(Observer, Scheduler.Worker, boolean, int)
ObservableObserveOn -> Observable : subscribe(Observer)
Observable -> RxJavaPlugins : onSubscribe(Observable,Observer)
RxJavaPlugins --> Observable : 返回ObservableObserveOn
Observable->ObservableSubscribeOn: subscribeActual(Observer)
note right : Observer对象实际上传递的是返回来的返回ObservableObserveOn
create SubscribeOnObserver
ObservableSubscribeOn -> SubscribeOnObserver : new(Observer)
ObservableSubscribeOn -> ObservableObserveOn : onSubscribe(Disposable)
note right : 实际上传递的是刚刚new出来的SubscribeOnObserver,
ObservableObserveOn -> Observer : onSubscribe
create SubscribeTask
note right: 实际上就是一个实现了Runnable的类
ObservableSubscribeOn -> SubscribeTask : 创建SubscribeTask，传递进去SubscribeOnObserver对象
ObservableSubscribeOn -> Scheduler : scheduleDirect(Runnable)
note right : Scheduler是抽象类，实际上调用的IOScheduler对象
Scheduler -> Scheduler : scheduleDirect(Runnable,long,TimeUnit)
Scheduler -> IoScheduler : CreateWorker
IoScheduler --> Scheduler : 返回EventLoopWorker
Scheduler -> RxJavaPlugins : onSchedule(Runnable)
RxJavaPlugins --> Scheduler : 返回Runnable
create DisposeTask
Scheduler -> DisposeTask : new(Runnable, Worker)
Scheduler -> EventLoopWorker : schedule(Runnable, long ,TimeUnit)
EventLoopWorker -> NewThreadWorker : scheduleActual(Runnable, long,TimeUnit,DisposableContainer)
NewThreadWorker -> RxJavaPlugins : onSchedule(Runnable)
RxJavaPlugins --> NewThreadWorker : 返回Runnable
create ScheduledRunnable
NewThreadScheduler -> ScheduledRunnable
ScheduledRunnable --> NewThreadWorker:返回ScheduledRunnable对象
NewThreadWorker -->> ScheduledThreadPoolExecutor : 异步调用submit














' user->ObservableCreate : 1.subscribeOn()
' create ObservableSubscribeOn
' ObservableCreate -> ObservableSubscribeOn : 2.new
' ObservableCreate->RxJavaPlugins : 3.onAssembly
' RxJavaPlugins -> user : 4.ObservableSubscribeOn
@enduml